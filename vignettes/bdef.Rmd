---
title: "An introduction to spatial deformations using B-splines"
author: "Guilherme Ludwig, Ronaldo Dias, Paul Sampson"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
fig_caption: yes
vignette: >
  %\VignetteIndexEntry{Introduction to spatial deformations using B-splines}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This vignette describes how to install and use the `bsplinedef` package, a package for finding spatial deformations using the tensor product of B-splines. This is a work in progress and subject to change. For now, the package fits the semi-parametric covariance model \[\Gamma(x_1, x_2) =  \sigma^2(\|f_1(x_1,x_2) - f_2(x_1,x_2)\|; \boldsymbol\Delta)\] where $x_1, x_2 \in G \subset \mathbb{R}^2$ are sampled spatial locations in a geostatistical domain $G;$ $f_1,$ $f_2$ are the tensor product of B-spline functions, each with $K_1 \times K_2$ basis functions, respectively; and $\sigma^2(\cdot)$ is a stationary, isotropic covariance function with parameters $\boldsymbol\Delta$. The parameters $\boldsymbol\Delta$ as well as B-spline coefficients $\boldsymbol\theta_1$ and $\boldsymbol\theta_2$ are estimated by minimizing \[Q(\boldsymbol\theta_1, \boldsymbol\theta_2, \boldsymbol\Delta) \propto |\boldsymbol\Sigma|^{-n/2} \exp\left\{-\frac{1}{2}\left(\mathbf{Y} - \boldsymbol\mu \right)^t \boldsymbol\Sigma^{-1} \left(\mathbf{Y} - \boldsymbol\mu \right)\right\},\] penalized by \[ \mathbf{P}(\boldsymbol\theta_1, \boldsymbol\theta_2) = \lambda \sum_{h=1}^2 \left[\rho \left (\theta_{i,j,h} - \theta_{i+1,j,h} \right ) + \rho \left (\theta_{i,j,h} - \theta_{i,j+1,h} \right ) \right],\] where $\rho$ is a concave function (TBD).

## Installation

The most recent version of `bsplinedef` is available at <https://github.com/guiludwig/bsplinedef>. To install the package directly from github, we recommed the `install_github` function available from the `devtools` package. 

```{r echo=FALSE}
knitr::opts_chunk$set(cache=TRUE)
```

```{r eval=FALSE}
library(devtools) # install if missing
install_github("guiludwig/bsplinedef")
```

The `bsplinedef` package depends on `RandomFields`, `fields` and `splines`, among others. It also uses `knitr` and `rmarkdown` to build the documentation.

## Usage: simulated example

First, we will consider a simulated example. 

```{r}
set.seed(1)
m <- 10
x1 <- (0:m)/m
x2 <- (0:m)/m
x <- as.matrix(expand.grid(x1,x2))
n <- nrow(x)
TIME <- 100
F1 <- function(x1,x2, a = 2.5, b = 1.0) {
x <- x1 - 0.5; y <- x2 - 0.5
angle <- a*exp(-(x*x+y*y)/(b*b)) + 3*pi/2
return(cos(angle)*x + sin(angle)*y + 0.5)
}
F2 <- function(x1,x2, a = 2.5, b = 1.0) {
x <- x1 - 0.5; y <- x2 - 0.5
angle <- a*exp(-(x*x+y*y)/(b*b)) + 3*pi/2
return(-sin(angle)*x + cos(angle)*y + 0.5)
}
```

The following figure displays the sampled spatial locations (in black) as well as the deformed locations with coordinates $y_1 = f_1(x_1,x_2)$ and $y_2 = f_2(x_1,x_2)$, in red. The black regular grid is also shown, deformed, in R. The marginal color maps display the functions $f_1$, $f_2.$

```{r echo=FALSE, fig.align="center", message=FALSE, fig.width=6, fig.height=6}
library(bsplinedef)
plotGrid(list(window = list(x = range(x1), y = range(x2)),
              x = x, def.x = cbind(F1(x[,1],x[,2]), 
                                   F2(x[,1],x[,2]))),
         F1 = F1, F2 = F2, nx = m + 1, ny = m + 1)
```

The `bsplinedef` inherits some syntax from the `RandomFields` package, particularly how to set up a covariance model for the D-distance. First, we will simulate data $Y$ on the D-coordinates $(y_1, y_2)$ using a stationary covariance model, with functions from the `RandomFields` package.

```{r message=FALSE}
 # Independent in time
covModel <- RMexp(var = 1, scale = 0.25, proj = "space") * RMnugget(var = 1, proj = "time")
data <- RFsimulate(covModel, x = F1(x[,1],x[,2]), y = F2(x[,1],x[,2]),
                   T = seq(from = 1, by = 1, len = TIME)) 
# Extracts values from object RFspatialPointsDataFrame
y  <- as.numeric(unlist(data@data))
```

For this example the spatial locations are simply stored in a $n \times 2$ matrix, while the response values are stored in a $n$-lenght numeric vector.

```{r}
str(x)
str(y)
```

The function `bdef` finds the appropriate deformations $\hat{f}_1,$ $\hat{f}_2,$ as well as estimating the parameters for the spatial covariance function. The default covariance function is a Mat&eacute;rn covariance function plus nugget effect, with differentiability parameter $\nu = 2.5$ (fixed), unknown variance $\sigma_\eta^2$, unknown scale parameter $\gamma$ and unknown nugget effect $\sigma_\varepsilon^2.$ In this case, we need to modify the default action to use an exponential covariance.

For example, fitting the model to the simulated dataset:

```{r}
# Parameters to be estimated set as NA
cov.to.estimate <- RMexp(var = NA, scale = NA) 
model <- bdef(x, y, tim = 1:TIME, cov.model = cov.to.estimate,
              df1 = 6, df2 = 6)
```

Estimated parameters can be recovered with

```{r}
model$model # Covariance model
```

If, for some reason, one needs the spline coefficients, they can also be extracted with

```{r}
model$theta1 # Spline coefficients for f_1
```

The fitting process supports some customization. For example, one may be interested in a different covariance function. We may change it with the following command:

```{r}
# Value set to $nu = 2.5$
G <- RMmatern(nu = 2.5, var = NA, scale = NA)
# documentation, values left as NA are to be estimated
model.matern <- bdef(x, y, tim = 1:TIME, cov.model = G)
model.matern$model
```

## Plotting tools

We provide two plotting functions along with the `bsplinedef` package. The first one, named `plotGrid`, displays the deformation grid on the data.

```{r fig.align="center", fig.align="center", message=FALSE, fig.width=6, fig.height=6}
plotGrid(model)
```

```{r fig.align="center", fig.align="center", message=FALSE, fig.width=6, fig.height=6}
plotGrid(model.matern)
```

The second function, `plotGDdist`, produces a comparison between sample covariances using the G-domain and D-domain distances for reference. It only works if all sampled sites have more than one observation, which might require pruning of the data to use.

```{r fig.align="center", message=FALSE, fig.width=6, fig.height=6}
plotGDdist(model)
```

One can also obtain the variogram using the `RandomFields` built in function.

```{r eval = FALSE, echo=FALSE, message=FALSE}
png("variog.png")
plot(model$model, ylim = c(0,2), xlim = c(0,0.7),
     model = list(`true model` = RMexp(var = 1, scale = .25)))
dev.off()
```

```{r eval = FALSE}
plot(model$model, ylim = c(0,2), xlim = c(0,0.7),
     model = list(`true model` = RMexp(var = 1, scale = .25)))
```

![](variog.png)